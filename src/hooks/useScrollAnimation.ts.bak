"use client";

import { useState, useEffect } from 'react';

interface ScrollAnimationReturn {
  scrollY: number;
  scrollProgress: number;
  getParallaxStyle: (speed: number) => { transform: string };
  isScrolling: boolean;
  scrollDirection: 'up' | 'down' | null;
}

export function useScrollAnimation(): ScrollAnimationReturn {
  const [scrollY, setScrollY] = useState(0);
  const [scrollProgress, setScrollProgress] = useState(0);
  const [isScrolling, setIsScrolling] = useState(false);
  const [scrollDirection, setScrollDirection] = useState<'up' | 'down' | null>(null);

  useEffect(() => {
    let scrollTimeout: NodeJS.Timeout;
    let lastScrollY = 0;
    let ticking = false;

    const updateScroll = () => {
      const currentScrollY = window.scrollY;
      const docHeight = document.documentElement.scrollHeight - window.innerHeight;
      const progress = docHeight > 0 ? (currentScrollY / docHeight) * 100 : 0;

      setScrollY(currentScrollY);
      setScrollProgress(progress);
      setIsScrolling(true);

      // Determine scroll direction
      if (currentScrollY > lastScrollY + 5) {
        setScrollDirection('down');
      } else if (currentScrollY < lastScrollY - 5) {
        setScrollDirection('up');
      }

      lastScrollY = currentScrollY;
      ticking = false;

      // Clear previous timeout
      clearTimeout(scrollTimeout);
      
      // Set scrolling to false after 150ms of no scroll
      scrollTimeout = setTimeout(() => {
        setIsScrolling(false);
      }, 150);
    };

    const handleScroll = () => {
      if (!ticking) {
        requestAnimationFrame(updateScroll);
        ticking = true;
      }
    };

    // Use passive scroll listener for better performance
    window.addEventListener('scroll', handleScroll, { passive: true });
    
    // Initial calculation
    updateScroll();

    return () => {
      window.removeEventListener('scroll', handleScroll);
      clearTimeout(scrollTimeout);
    };
  }, []);

  const getParallaxStyle = (speed: number): { transform: string } => {
    const yPos = -(scrollY * speed);
    return {
      transform: `translate3d(0, ${yPos}px, 0)`
    };
  };

  return {
    scrollY,
    scrollProgress,
    getParallaxStyle,
    isScrolling,
    scrollDirection
  };
}

// Throttle function for performance
function throttle<T extends (...args: any[]) => any>(
  func: T,
  limit: number
): (...args: Parameters<T>) => void {
  let inThrottle: boolean;
  return function(this: any, ...args: Parameters<T>): void {
    if (!inThrottle) {
      func.apply(this, args);
      inThrottle = true;
      setTimeout(() => inThrottle = false, limit);
    }
  };
}